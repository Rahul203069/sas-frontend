// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}


enum NotificationType {
  APPOINTMENT_REMINDER
  ACTION_REQUIRED
  LEAD_STATUS_UPDATE
  
  CONVERSATION_UPDATE
  SYSTEM_ALERT
}

enum bottype {

BUYER
SELLER

}


model notification {
  id          String   @id @default(uuid())
  userId      String
  type        NotificationType
  metadata    Json?
  read        Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user        User     @relation(fields: [userId], references: [id])
}

model User {
  id           String   @id @default(uuid()) @unique
  email        String   @unique
  name         String
  password     String
  role         Role     @default(ADMIN)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  image        String?
  otp           String?
  areacode      String?
  phonenumber   String?
   googlecalendarmetadata  Json?
  timeZone   String?
   bot       Bot[]
 
  availabaleSlots Json?
  phoneverifed   Boolean @default(false)
  // One-to-one relation with Twilio
  twilio       Twilio?
  
  // Other relations
  notifications notification[]
  leads        Lead[]
  conversations Conversation[]
  appointments Appointment[]
  chatSessions ChatSession[]
}

model Twilio {
  id          String   @id @default(uuid())
  userId      String   @unique // Ensures one Twilio per User
  phone       String
  areacode    Int?
  authToken   String
  accountSid  String 
  sid         String 
  metadata    Json
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Reference to User - establishes the one-to-one relation

  user        User     @relation(fields: [userId], references: [id])
}


enum Role {
  USER
  ADMIN
}

model Lead {
  id              String      @id @default(uuid())
  name            String
  email           String[]
  phone           String[]
  smscapablephone String[]
  state           LeadState?
  address         String
  status          LeadStatus  @default(JUNK)
  source          LeadSource
  data            Json?
  initiated       Boolean     @default(false)
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  
  // User relation
  userId          String
  owner           User        @relation(fields: [userId], references: [id])
  
  // Bot relation - botId is NOT unique, allowing multiple leads per bot
  botId           String      // No @unique constraint = non-unique
  bot             Bot         @relation(fields: [botId], references: [id])
  
  // Other relations
  contacts        Contact[]
  conversations   Conversation[]
  appointments    Appointment[]
  chatSessions    ChatSession[]
}
enum LeadStatus {
  HOT
  WARM
  JUNK
}

enum LeadState {
  INITIATED
  REPLIED
  TALKING
  APPOINTMENT
}

enum LeadSource {
  HUBSPOT
  GOOGLE_SHEETS
  REDX
  MANUAL
}

model Contact {
  id       String     @id @default(uuid())  
  leadId   String
  type     ContactType // EMAIL or PHONE
  value    String
  createdAt DateTime @default(now())

  lead     Lead @relation(fields: [leadId], references: [id])
}

enum ContactType {
  EMAIL
  PHONE
}

model Conversation {
  id          String   @id @default(uuid())  
  leadId      String   
  userId      String
  type        bottype?     

botId      String
  bot         Bot? @relation(fields: [botId], references: [id])

  messages    Message[]
  aiSummary   String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  lead        Lead      @relation(fields: [leadId], references: [id])
  user        User?    @relation(fields: [userId], references: [id])
  chatSession ChatSession?
}

model Message {
  id           String     @id @default(uuid())  
  conversationId String  
  botId        String
  leadId       String
  sender        SenderType
  content       String
  timestamp     DateTime   @default(now())

  conversation  Conversation @relation(fields: [conversationId], references: [id])


}

enum SenderType {
  AI
  USER
  LEAD
}







model Appointment {
  id           String   @id @default(uuid())  
  leadId       String  
  userId       String
  scheduledAt  DateTime  
  status       AppointmentStatus @default(PENDING)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  lead         Lead @relation(fields: [leadId], references: [id])
  user         User @relation(fields: [userId], references: [id])
}


model ChatSession {
  id          String   @id @default(uuid())
  userId      String
  leadId      String
conversationId String? @unique

  sessionId   String   @unique

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  conversation Conversation? @relation(fields: [conversationId], references: [id])
lead         Lead     @relation(fields: [leadId], references: [id])
  user        User     @relation(fields: [userId], references: [id])
}


model Testchat {

id String  @id @default(uuid())
botid  String?

userid    String 

message   Json?  
availableslots Json?
generatedslots Json?
suggestedslots Json?
   



}


  model testdata{
  id String @id @default(uuid())
  data String?
  name String?
  }

model EnrichmentQuestion {
  id       String @id @default(uuid())
  question String
  
  // Relations
  Bot Bot[] @relation("BotEnrichment")
 
}

model Bot {
  id                String   @id @default(uuid())
  userid            String  
  type              bottype
  name              String
  bussinessinfo     String

  enrichment        EnrichmentQuestion[] @relation("BotEnrichment")
  appointmentsetter Boolean 

  islive            Boolean @default(false)
  startingmessage   String
  prompt            String?


  // Reference to User
  user              User  @relation(fields: [userid], references: [id])

  // Opposite relation to Lead
  lead              Lead[]

  // Opposite relation to Conversation
  conversation      Conversation[]
}





enum AppointmentStatus {
  PENDING
  CONFIRMED
  CANCELED
}

enum leadtype {
  BUYER
  SELLER

}


