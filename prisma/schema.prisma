// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}


enum NotificationType {
  APPOINTMENT_REMINDER
  ACTION_REQUIRED
  LEAD_STATUS_UPDATE
  
  CONVERSATION_UPDATE
  SYSTEM_ALERT
}

enum bottype {

BUYER
SELLER

}






model MessageJobs {
  id            String   @id @default(uuid())
  userId        String
  totalMessages Int
  messageSent   Int
  error         Int
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  // Relation to User
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("messagejobs")
}









model notification {
  id          String   @id @default(uuid())
  userId      String
  type        NotificationType
  metadata    Json?
  read        Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user        User     @relation(fields: [userId], references: [id])
}

model User {
  id                      String   @id @default(uuid()) @unique
  email                   String   @unique
  name                    String
  password                String
  role                    Role     @default(ADMIN)
  createdAt              DateTime @default(now())
  updatedAt              DateTime @updatedAt
  image                  String?
  otp                    String?
  areacode               String?
  phonenumber            String?
  googlecalendarmetadata Json?
  timeZone               String?
  availabaleSlots        Json?
  phoneverifed           Boolean  @default(false)
  
  // One-to-one relation with Twilio
  twilio                 Twilio?
  
  // One-to-many relations
  bot                    Bot[]
  notifications          notification[]
  leads                  Lead[]
  conversations          Conversation[]
  appointments           Appointment[]
  chatSessions           ChatSession[]
  messageJobs            MessageJobs[]  // Added one-to-many relation
}

enum Role {
  ADMIN
  USER
  MODERATOR
}

model Twilio {
  id          String   @id @default(uuid())
  userId      String   @unique // Ensures one Twilio per User
  phone       String
  areacode    Int?
  authToken   String
  accountSid  String 
  sid         String 
  metadata    Json
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Reference to User - establishes the one-to-one relation

  user        User     @relation(fields: [userId], references: [id])
}




model Lead {
  id              String      @id @default(uuid())
  name            String
  email           String[]
  phone           String[]
  smscapablephone String[]
  state           LeadState?
  address         String
  status          LeadStatus  @default(JUNK)
  source          LeadSource
  data            Json?
  initiated       Boolean     @default(false)
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  
  // User relation
  userId          String
  owner           User        @relation(fields: [userId], references: [id])
  
  // Bot relation - botId is NOT unique, allowing multiple leads per bot
  botId           String
  bot             Bot         @relation(fields: [botId], references: [id])
  
  // Other relations
  contacts        Contact[]
  conversations   Conversation[]
  appointments    Appointment[]
  chatSessions    ChatSession[]
  property        Property?   // One-to-one: One lead can have ONE property (optional)
}

model Property {
  id                String    @id @default(uuid())
  propertyType      String?   // "House", "Condo", "Apartment", etc.
  propertyAddress   String?
  zipCode           String?
  bedrooms          Int?
  bathrooms         Float?    // Using Float to support values like 2.5
  squareFootage     Int?
  yearBuilt         Int?
  lotSize           String?   // Storing as string to preserve formatting like "0.25 acres"
  garageCount       Int?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  
  // Lead relation (one-to-one)
  leadId            String    @unique  // @unique makes it one-to-one
  lead              Lead      @relation(fields: [leadId], references: [id], onDelete: Cascade)
}

enum LeadStatus {
  HOT
  WARM
  JUNK
}

enum LeadState {
  INITIATED
  REPLIED
  TALKING
  APPOINTMENT
}

enum LeadSource {
  HUBSPOT
  GOOGLE_SHEETS
  REDX
  MANUAL
}

model Contact {
  id       String     @id @default(uuid())  
  leadId   String
  type     ContactType // EMAIL or PHONE
  value    String
  createdAt DateTime @default(now())

  lead     Lead @relation(fields: [leadId], references: [id])
}

enum ContactType {
  EMAIL
  PHONE
}

enum  ConversationStatus {
  TALKING
  APPOINTMENTSETTING
}

model Conversation {
  id          String   @id @default(uuid())  
  leadId      String   
  userId      String
  type        bottype?     
status ConversationStatus @default(TALKING)
appointmentdataprompt     String?      

botId      String
  bot         Bot? @relation(fields: [botId], references: [id])

  messages    Message[]
  aiSummary   String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  lead        Lead      @relation(fields: [leadId], references: [id])
  user        User    @relation(fields: [userId], references: [id])
  chatSession ChatSession?
}

model Message {
  id           String     @id @default(uuid())  
  conversationId String  
  botId        String
  leadId       String
  sender        SenderType
  content       String
  timestamp     DateTime   @default(now())

  conversation  Conversation @relation(fields: [conversationId], references: [id])


}

enum SenderType {
  AI
  USER
  LEAD
}







model Appointment {
  id           String   @id @default(uuid())  
  leadId       String  
  userId       String
  scheduledAt  DateTime  
  duration     Int      @default(30) // duration in minutes
  status       AppointmentStatus @default(PENDING)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  completed       Boolean @default(false) 
  lead         Lead @relation(fields: [leadId], references: [id])
  user         User @relation(fields: [userId], references: [id])
}


model TestAppointment {
  id           String   @id @default(uuid())  

  userId       String 
  scheduledAt  DateTime  
  status       AppointmentStatus @default(PENDING)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

}





model ChatSession {
  id          String   @id @default(uuid())
  userId      String
  leadId      String
conversationId String? @unique

  sessionId   String   @unique

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  conversation Conversation? @relation(fields: [conversationId], references: [id])
lead         Lead     @relation(fields: [leadId], references: [id])
  user        User     @relation(fields: [userId], references: [id])
}


model Testchat {

id String  @id @default(uuid())
botid  String?

userid    String 

message   Json?  
availableslots Json?
generatedslots Json?
suggestedslots Json?
   



}


  model testdata{
  id String @id @default(uuid())
status ConversationStatus @default(TALKING)
botid   String?
  data String?
  name String?
  }

model EnrichmentQuestion {
  id       String @id @default(uuid())
  question String
  
  // Relations
  Bot Bot[] @relation("BotEnrichment")
 
}

model Bot {
  id                String   @id @default(uuid())
  userid            String  
  type              bottype
  name              String
  bussinessinfo     String

  enrichment        EnrichmentQuestion[] @relation("BotEnrichment")
  appointmentsetter Boolean 

  islive            Boolean @default(false)
  startingmessage   String
  prompt            String?


  // Reference to User
  user              User  @relation(fields: [userid], references: [id])

  // Opposite relation to Lead
  lead              Lead[]

  // Opposite relation to Conversation
  conversation      Conversation[]
}





enum AppointmentStatus {
  PENDING

  COMPLETED
}

enum leadtype {
  BUYER
  SELLER

}









